"""
Sample Data Generator and Data Loading Utilities
=================================================
Provides realistic synthetic production data for:
    1. Pre-populating the UI with a ready-to-use example
    2. User CSV upload parsing and validation
    3. Future EIA DPR data integration stub

Synthetic data is generated by applying known Arps parameters plus
normally distributed noise — same approach as the test suite, but
with richer metadata for the UI.
"""

import numpy as np
import pandas as pd
from dataclasses import dataclass
from typing import Optional
from core.type_curves import TypeCurve, MIDLAND_BASIN_P50, get_curve
from core.decline_curves import hyperbolic_rate


@dataclass
class WellProductionData:
    """
    Production history for a single well — input to DeclineCurveFitter.
    """
    well_name: str
    months: np.ndarray              # 0-based month index
    production_boe_per_day: np.ndarray  # Daily rate (BOE/day)
    source: str = "synthetic"       # 'synthetic' | 'user_upload' | 'eia'
    metadata: dict = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

    def to_dataframe(self) -> pd.DataFrame:
        """Export production history as a DataFrame for display."""
        return pd.DataFrame({
            'Month': self.months + 1,  # 1-based for display
            'Production (BOE/day)': np.round(self.production_boe_per_day, 1)
        })


def generate_sample_well(
    type_curve_name: str = "Midland Basin P50",
    noise_level: float = 0.05,
    months: int = 36,
    seed: int = 42
) -> WellProductionData:
    """
    Generate synthetic production history from a type curve.

    Adds realistic noise (log-normal, not Gaussian) to avoid negative
    production values and better match actual well variability.

    Args:
        type_curve_name: Key from ALL_CURVES registry
        noise_level:     Fractional noise (0.05 = 5% month-to-month variability)
        months:          Number of months of history to generate
        seed:            Random seed for reproducibility

    Returns:
        WellProductionData ready for DeclineCurveFitter.fit()
    """
    np.random.seed(seed)
    tc = get_curve(type_curve_name)

    t = np.arange(0, months, dtype=float)
    q_true = hyperbolic_rate(t, tc.qi, tc.Di, tc.b)

    # Log-normal noise: multiplicative, prevents negative values
    noise = np.random.lognormal(mean=0.0, sigma=noise_level, size=months)
    q_noisy = np.maximum(q_true * noise, 1.0)

    return WellProductionData(
        well_name=f"Sample Well — {tc.name}",
        months=t,
        production_boe_per_day=q_noisy,
        source="synthetic",
        metadata={
            "type_curve": type_curve_name,
            "true_qi": tc.qi,
            "true_Di": tc.Di,
            "true_b": tc.b,
            "noise_level": noise_level,
            "seed": seed
        }
    )


def parse_uploaded_csv(file_obj) -> Optional[WellProductionData]:
    """
    Parse a user-uploaded CSV file into WellProductionData.

    Accepted formats (auto-detected):
        Format A: Two columns — 'Month', 'Production (BOE/day)'
        Format B: Two columns — 'month', 'boe_per_day'
        Format C: Single column of production values (month = row index + 1)

    Returns:
        WellProductionData if parsing succeeds, None if file is invalid.
        Call parse_error attribute for user-facing error message if None.
    """
    try:
        df = pd.read_csv(file_obj)

        # Attempt column detection
        col_map = {c.lower().strip(): c for c in df.columns}

        # Find production column
        prod_col = None
        for candidate in ['production (boe/day)', 'boe_per_day', 'boe/day',
                          'production', 'rate', 'q']:
            if candidate in col_map:
                prod_col = col_map[candidate]
                break

        # Find month column
        month_col = None
        for candidate in ['month', 'months', 'time', 'month_index']:
            if candidate in col_map:
                month_col = col_map[candidate]
                break

        if prod_col is None:
            # Fallback: assume first numeric column is production
            numeric_cols = df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) == 0:
                return None
            prod_col = numeric_cols[0]

        production = pd.to_numeric(df[prod_col], errors='coerce').dropna().values

        if month_col is not None:
            months = pd.to_numeric(df[month_col], errors='coerce').dropna().values
            months = months - months[0]  # Zero-index
        else:
            months = np.arange(len(production), dtype=float)

        if len(production) < 6:
            return None

        return WellProductionData(
            well_name="Uploaded Well",
            months=months[:len(production)],
            production_boe_per_day=production,
            source="user_upload"
        )

    except Exception:
        return None


# Convenience: pre-built sample wells for each sub-basin
SAMPLE_WELLS = {
    "Midland Basin P50":    generate_sample_well("Midland Basin P50",    seed=42),
    "Delaware Basin P50":   generate_sample_well("Delaware Basin P50",   seed=7),
    "Central Platform P50": generate_sample_well("Central Platform P50", seed=13),
}
